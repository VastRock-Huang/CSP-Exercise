/*
	题目编号：201604-1
	题目名称：折点计数

	题干：
		给定n个整数表示一个商店连续n天的销售量。如果某天之前销售量在增长，
	而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一
	天销售量增长，也称这一天为折点。其他的天都不是折点。如下图中，第3天
	和第6天是折点。 
		给定n个整数a1, a2, …, an表示销售量，请计算出这些天总共有多少个折
	点。 
		为了减少歧义，我们给定的数据保证：在这n天中相邻两天的销售量总是不
	同的，即ai-1≠ai。注意，如果两天不相邻，销售量可能相同。

	输入：
		输入的第一行包含一个整数n。 
		第二行包含n个整数，用空格分隔，分别表示a1, a2, …, an。

	输出：
		输出一个整数，表示折点出现的数量。
*/
/*
#include<iostream>

using namespace std;

int main()
{
	int n;
	cin >> n;
	
	int* a = new int[n];
	for (int i = 0; i < n; i++)
		cin >> a[i];
	int num = 0;
	int flag = ((a[1] - a[0] > 0) ? 1 : -1);
	for (int i = 1; i < n - 1; i++)
	{
		if ((a[i + 1] - a[i]) * flag < 0)
		{
			flag *= -1;
			num++;
		}
	}
	cout << num;

	delete[]a;

	//int a0, a1;		//不使用数组的方法
	//cin >> a0 >> a1;
	//int num = 0;
	//int flag= ((a1 - a0 > 0) ? 1 : -1);
	//for (int i = 2; i < n; i++)
	//{
	//	cin >> a0;
	//	if ((a0 - a1) * flag < 0)
	//	{
	//		flag *= -1;
	//		num++;
	//	}
	//	a1 = a0;
	//}
	//cout << num;

	return 0;
}


/*
	题目编号：201604-2
	题目名称：俄罗斯方块

	题干：
		俄罗斯方块是俄罗斯人阿列克谢・帕基特诺夫发明的一款休闲游戏。 
		游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方
	块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的
	上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边
	缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图
	的某一行全放满了方块，则该行被消除并得分。 
		在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，
	也不需要处理消行和得分。 
		具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要
	给出最终的方格图。

	输入：
		输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如
	果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时候有方块。
	输入保证前4行中的数字都是0。 
		输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，
	同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是
	连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。 
		第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一
	列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块图案的最左边
	一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例）
	输出：
		输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格
	图。注意，你不需要处理最终的消行。
*/
/*
#include<iostream>

using namespace std;

int main()
{
	int bg[15][10];
	int i, j;
	for (i = 0; i < 15; i++)
		for (j = 0; j < 10; j++)
			cin >> bg[i][j];
	int graph[4][4];
	int start;	//表示板块有数字的最大行(0<=start<=3)
	for (i = 0; i < 4; i++)
		for (j = 0; j < 4; j++)
		{
			cin >> graph[i][j];
			if (graph[i][j])
				start = i;
		}
	int left;
	cin >> left;

	int bgx, bgy = left - 1;
	int ghx, ghy;
	int flag = 1;
	for (bgx = 4 - start; flag && bgx < 15 - start; bgx++)
	{
		for (ghx = 0; flag && ghx < start + 1; ghx++)
			for (ghy = 0; flag && ghy < 4; ghy++)
				if (bg[bgx + ghx][bgy + ghy] + graph[ghx][ghy] == 2)
					flag = 0;
		if (!flag)	//为了保留flag=0时的循环变量bgx的值，需要break跳出
			break;
	}

	for (i = 0; i < start+1; i++)
		for (j = 0; j < 4; j++)
			bg[bgx - 1 + i][bgy + j] += graph[i][j];

	for (i = 0; i < 15; i++)
	{
		for (j = 0; j < 10; j++)
			cout << bg[i][j] << ' ';
		cout << endl;
	}

	return 0;
}
	//易错点：关于使用flag跳出多重for循环时，flag=0时的所有语句3均会执行，
	//至下一次判断时才退出循环，因此flag=0时的循环变量和跳出循环后的循环变量的
	//值会不同，详见下程序。若程序需要用到跳出时的循环变量值，需要配合break使用
	//如上面程序，或者使用goto语句


//#include<iostream>
////#define F 
//
//using namespace std;
//int main()
//{
//	int i, j, flag = 1;
//	for (i = 0; flag && i < 5; i++)
//		for (j = 0; j < 4 && flag; j++)
//		{
//			if (i == 3 && j == 3)
//#ifdef  F
//				flag = 0;
//#endif
//#ifndef F
//			goto end;
//#endif // !F
//		}
//	end:
//	cout << i << j;
//	return 0;
//}

/**/